/Комментарии для файла mainO0.s

.file	"main.c"                  / Указывает имя исходного файла C, из которого сгенерирован этот ассемблерный код.
	.text                       / Начало текстового сегмента (содержит исполняемый код).
	.section	.rodata         / Начало секции только для чтения (для неизменяемых данных).
	.align 8                    / Выравнивание данных на границу 8 байт.
.LC0:
	.string	"Fibonacci element number %d= %lld\n" / Строка, используемая в printf.
	.text                       / Возвращаемся в текстовый сегмент для размещения исполняемого кода.
	.globl	main                / Делаем метку `main` глобальной (доступна из других объектов).
	.type	main, @function     / Указываем, что `main` — это функция.
main:
.LFB0:
	.cfi_startproc             / Начало отладочной информации CFI
	endbr64
	pushq	%rbp		   /Сохраняем указатель
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16 	   /Сохраняем адрес %rbp в CFI.
	movq	%rsp, %rbp         /Устанавливаем %rbp (указатель базы) равным %rsp
	.cfi_def_cfa_register 6
	subq	$16, %rsp          / Выделяем 16 байт в стеке для локальных переменных.
	movl	$11, -4(%rbp)      / Помещаем число 11 в локальную переменную на стеке (-4 от %rbp).
	movl	-4(%rbp), %eax     / Загружаем значение локальной переменной (11) в регистр %eax.
	movl	%eax, %edi         / Копируем %eax (параметр для вызова функции) в регистр %edi.
	call	fibonacci@PLT      / Вызываем функцию `fibonacci`, через таблицу PLT (Procedure Linkage Table).
	movq	%rax, %rdx         / Сохраняем результат вызова (число Фибоначчи) из %rax в %rdx.
	movl	-4(%rbp), %eax     / Загружаем значение локальной переменной (11) в %eax.
	movl	%eax, %esi         / Передаем значение (номер элемента) в %esi для printf.
	leaq	.LC0(%rip), %rax   / Загружаем адрес строки .LC0 в %rax.
	movq	%rax, %rdi         / Передаем адрес строки в %rdi (первый аргумент для printf).
	movl	$0, %eax           / Устанавливаем %eax в 0 (указатель на отсутствие ошибок).
	call	printf@PLT         / Вызываем функцию printf через таблицу PLT.
	movl	$0, %eax           / Устанавливаем код возврата функции main в 0.
	leave                      / Восстанавливаем стек и указатель базы (%rbp).
	.cfi_def_cfa 7, 8          / Указываем новое состояние стека (CFI).
	ret                        / Возвращаем управление вызвавшей функции.
	.cfi_endproc               / Конец отладочной информации CFI.
.LFE0:
	.size	main, .-main        / Указываем размер функции main.
	.ident	"GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0" / Информация о компиляторе.
	.section	.note.GNU-stack,"",@progbits / Указывает, что стек не выполняемый.
	.section	.note.gnu.property,"a"       / Секция с атрибутами GNU.
	.align 8                   / Выравнивание данных на границу 8 байт.
	.long	1f - 0f            / Длина первой секции.
	.long	4f - 1f            / Длина второй секции.
	.long	5
0:
	.string	"GNU"             / Строка "GNU".
1: 
	.align 8                   / Выравнивание данных на границу 8 байт.
	.long	0xc0000002         / Данные с атрибутами GNU.
	.long	3f - 2f            / Длина следующей секции.
2:
	.long	0x3
3:
	.align 8                   / Выравнивание данных на границу 8 байт.
4: